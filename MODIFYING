# INSTRUCTIONS FOR MODIFYING ATLAS

This is less of a guide on how to modify the code and more on how the code is set up so you can know where to look to start modifications.

While there are both FORTRAN and C parts to the whole code, it's easiest to think of it as a FORTRAN code. The extra C code is really just for an extra module that is encapsulated by the rest of the FORTRAN.

The code works by tracking a set of tiles in memory, turning them into power spectra, fitting them, writing the fitting results to the disk, then continuing on to do more tiles. The number of tiles you can keep in memory for a single batch depends on the core count, the memory per core, and the tile size. While there is a way of letting the code figure out the appropriate number by itself, it's often useful to force the number using the -maxtiles command-line option.

The entry-point for the whole code is Main.F90. In this, you can see how it sets up the number of tiles it needs to process over the course of the full run, then loops over batches until it has processes the correct number of tiles. The main loop in Main.F90 just calls TrackTiles() (from Track.F90) on some number of tiles in each MPI process. 

Track.F90 contains most of the meat of the tracking code. Each process has some number of tiles to track (usually 2ish) from the same set of Dopplergrams. The tracking in TrackTiles works by letting each process load some number of Dopplergrams (to allow for parallel I/O), letting all processors share these Dopplergrams (alltoallv), then for each locally stored tile, compute the projections of these Dopplergrams and add the result to the tiles. Typically, around 1% of all the Dopplergrams are read in and shared between processors for a tracking 'step'. This limits the amount of memory allocated for Dopplergrams on each core. Once each tile has been appended with new data from the Dopplergrams, new Dopplergrams are read into the same memory locations and shared. 

The azimuthal equidistant projection (Postel) procedure can be found in Projection(), also in Track.F90. The math there is almost exactly taken from mtrack, the HMI pipeline tracking code. It can be a little dense, but I've tried to leave enough comments to understand it. The input is a single Dopplergram image (plus some parameters), and the output is a square array that is a single slice of a tracked data cube.

Once TrackTiles has completed compiling the tracked cubes, it passes it along to the Make_Pspec() routine found in Pspec.F90. This code steps through the process of turning a tracked data cube into a power spectrum, all still in memory. It does a decent job at freeing up memory once it is not needed, and so (I believe) the original tracked data cube is lost once the power spectrum is made. Instead of passing the spectrum back to the routine that called Make_Pspec(), it passes it forward to FitPspec() found in Fit.F90. Once there, the power spectrum is passed to the fitting procedure, and the ring fits are gathered after the fact and written to the disk in append-mode. The code then returns back to TrackTiles() to start tracking the next set of tiles from the first Dopplergrams. 

For parallelism, the same power spectrum is passed to many instances of the fitting code with threading (OpenMP). Each instance is told to only fit a small range of wavenumbers.

The FitPspec() routine calls the C code for ring fitting. It calls the method fit_wrapper(), found in fit_wrapper.c. This wrapper is necessary because while the fitting code allows for a few types of input (command-line, input files, pipeline directives), direct FORTRAN calling is not by default one of them. The wrapper code organizes all of the data passed from FORTRAN and just gets it ready for fitting. This involved copying the power spectrum into a multi-dimensional array and setting a bunch of parameters that tell the fitting code what to do.

One important bit of information the fitting code needs is a guess table (often called a model file in the code). While there is some code available to read in guess tables, I have found it's best to avoid having each fitting instance read the same exact file over and over again. Instead of having one processor read it and share it around, I just made a static header file that contains all of the guess table parameters. This way, each process has it in memory from the start. Modifying the guess table will involve changing the source code, but this does not need to be done often. The guess table file for 16-degree tiles is guess_table_16.h. 

The file mrf_fit.c contains the primary (non-wrapper) function for ring fitting. This sets up all of the data inputs, fitting bounds, and guess values, then goes through each wavenumber (that it was told to do) and fits the modes. At the end, the fitted mode parameters are stored in an output data structure that the fit_wrapper takes apart and linearizes so that FORTRAN can deal with it later.
